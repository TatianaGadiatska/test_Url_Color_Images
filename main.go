package main

import (
	"database/sql"
	"fmt"
	"github.com/FogCreek/mini"
	_ "github.com/lib/pq"
	"golang.org/x/image/draw"
	"golang.org/x/net/html"
	"html/template"
	"image"
	"log"
	"math"
	"net/http"
	"os"
	"os/user"
	"strconv"
	_ "strconv"
	"strings"
	"sync"
	"unicode/utf8"

	_ "image/jpeg"
)

type recordUrl struct {
	Id            int
	UrlImg, Color string
}

type ViewData struct {
	UrlImgData []recordUrl
}

func main() {

	links := generatorURL()

	fmt.Printf("\nСкачено %v ссылок \n", len(links))

	connStr := "user=postgres password=123 dbname=mydb sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	chk(err)

	urlColor := makeUrlColor(links)
	//fmt.Println(urlColor)

	deleteTable(db)

	creatTable(db)

	insertUrl(db, urlColor)

	result, err := show(db)

	format(result)

	defer db.Close()
}

func makeUrlColor(links []string) map[string]string {
	urlColor := make(map[string]string)
	for _, url := range links {
		imgTemp := downloadFromUrl(url)
		colorTemp := dominateColor2(imgTemp)
		urlColor[url] = colorTemp
		//log.Print(urlColor)
	}
	return urlColor
}

func generatorURL() []string {
	//https://wallpaperstock.net/wallpapers_p2.html
	var s string = "https://wallpaperstock.net/wallpapers.html"
	var allUrl []string
	var workers int = 6
	var mutex sync.Mutex
	ch := make(chan []string)
	for i := 2; i < workers+2; i++ {
		mutex.Lock()
		var sTemp string = s[:37] + "_p" + strconv.Itoa(i) + s[37:]
		//fmt.Println(sTemp)
		go findLinks(sTemp, ch)

		mutex.Unlock()
		allUrl = append(allUrl, <-ch...)
	}
	return allUrl
}

func chk(err error) {
	if err != nil {
		fatal(err)
	}
}

func fatal(v interface{}) {
	fmt.Println("Error ", v)
	os.Exit(1)
}

func params() string {
	u, err := user.Current()
	chk(err)
	cfg, err := mini.LoadConfiguration(u.HomeDir + "/.bdUrlImg.ini")
	chk(err)
	info := fmt.Sprintf("host=%s port=%s dbname=%s "+
		"sslmode=%s user=%s password=%s ",
		cfg.String("host", "127.0.0.1"),
		cfg.String("port", "5432"),
		cfg.String("dbname", u.Username),
		cfg.String("sslmode", "disable"),
		cfg.String("user", u.Username),
		cfg.String("pass", ""),
	)
	return info
}

func creatTable(db *sql.DB) {

	var err error
	_, err = db.Exec("CREATE TABLE IF NOT EXISTS " +
		`imgUrlTable("id" integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,` +
		`"urlName" varchar(100), "color" varchar(25))`)
	chk(err)
	fmt.Println("OK DB")
}

func insertUrl(db *sql.DB, urlColorBd map[string]string) {
	for key, value := range urlColorBd {
		db.Exec("insert into imgUrlTable values(default, $1, $2)", key, value)
	}
}

func deleteTable(db *sql.DB) {
	db.Exec("drop table imgUrlTable")
}

func findLinks(url string, c chan []string) {
	resp, err := http.Get(url)
	chk(err)

	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()

	}

	doc, err := html.Parse(resp.Body)
	resp.Body.Close()

	c <- visit(nil, doc)
}

func visit(links []string, n *html.Node) []string {
	if n.Type == html.ElementNode && n.Data == "img" {
		for _, a := range n.Attr {
			if a.Key == "src" && strings.Contains(a.Val, "wallpapers/thumbs") {
				links = append(links, "https:"+a.Val)
			}
		}
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		links = visit(links, c)
	}

	return links
}

func show(db *sql.DB) ([]recordUrl, error) {
	rows, err := db.Query("SELECT * FROM imgUrlTable")
	chk(err)
	defer rows.Close()
	var rs = make([]recordUrl, 0)
	var rec recordUrl
	for rows.Next() {
		err = rows.Scan(&rec.Id, &rec.UrlImg, &rec.Color)
		chk(err)
		rs = append(rs, rec)
	}
	err = rows.Err()
	chk(err)
	return rs, nil
}

func format(rs []recordUrl) {

	var max, tmp int
	for _, v := range rs {
		tmp = utf8.RuneCountInString(v.UrlImg)
		if max < tmp {
			max = tmp
		}
	}
	s := "%-" + strconv.Itoa(max) + "s"
	for _, v := range rs {
		fmt.Printf("%3d   "+s+"   %s\n", v.Id, v.UrlImg, v.Color)
	}

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {

		data := ViewData{
			UrlImgData: rs,
		}

		tmpl, _ := template.ParseFiles("index.html")
		tmpl.Execute(w, data)
	})

	fmt.Println("Server is listening...")
	http.ListenAndServe(":8181", nil)
}

func downloadFromUrl(url string) image.Image {
	resp, err := http.Get(url)
	if err != nil {
		// handle error
		log.Fatal(err)
	}
	defer resp.Body.Close()

	img, _, err := image.Decode(resp.Body)
	chk(err)
	log.Printf("Image type: %T", img)

	// создаём пустое изображение для
	// записи необходимого размера
	dst := image.NewRGBA(image.Rect(0, 0, 200, 200))
	// изменение размера
	draw.CatmullRom.Scale(dst, dst.Bounds(), img, img.Bounds(), draw.Over, nil)

	return dst
}

func dominateColor(img image.Image) (gominateColor string) {
	var (
		totalR, totalG, totalB, i, j uint8
		width                        uint8 = 200
		height                       uint8 = 200
	)
	// Подсчитать суммарные значения по RGB
	for i = 0; i < width; i++ {
		for j = 0; j < height; j++ {
			r, g, b, _ := img.At(int(i), int(j)).RGBA()
			totalR += uint8((r >> 16) & 0xFF)
			totalG += uint8((g >> 8) & 0xFF)
			totalB += uint8(b & 0xFF)
		}
	}
	// Определение значений RGB основного цвета
	avgR := math.Round(float64(totalR / width / height))
	avgG := math.Round(float64(totalG / width / height))
	avgB := math.Round(float64(totalB / width / height))

	// Перевести RGB в HSV
	R := avgR / 255
	G := avgG / 255
	B := avgB / 255

	maxRGB := math.Max(math.Max(R, G), B)
	minRGB := math.Max(math.Max(R, G), B)
	delta := maxRGB - minRGB

	// Цветовой тон
	var h, hue, saturation, value float64
	if delta != 0 {
		if maxRGB == R {
			h = (G - B) / delta
		}
		if maxRGB == G {
			h = 2 + (B-R)/delta
		}
		if maxRGB == B {
			h = 4 + (R-G)/delta
		}
	}
	hue = math.Round(h * 60)
	if hue < 0 {
		hue += 360
	} else {
		hue = 0
	}

	// Насыщенность
	if maxRGB != 0 {
		saturation = math.Round(delta / maxRGB * 100)
	} else {
		saturation = 0
	}

	// Яркость
	value = math.Round(maxRGB * 100)

	// определяем цвет

	// Яркость меньше 30%
	var dominColor string

	if value < 75 {
		// Черный
		dominColor = "#000000"
	} else {
		// Яркость больше 85% и насыщенность меньше 15%
		if value > 190 && saturation < 27 {
			// Белый
			dominColor = "#FFFFFF"
		} else {
			// Насыщенность меньше 25%
			if saturation < 53 && value < 185 {
				// Серый
				dominColor = "#909090"
			}
		}
	}
	// Определить цвет по цветовому тону
	// Красный
	if hue > 320 || hue <= 40 {
		dominColor = "#FF0000"
	} else {
		// Розовый
		if hue > 260 && hue <= 320 {
			dominColor = "#FF00FF"
		} else {
			// Синий
			if hue > 190 && hue <= 260 {
				dominColor = "#0000FF"
			} else {
				// Голубой
				if hue > 175 && hue <= 190 {
					dominColor = "#00FFFF"
				} else {
					// Зеленый
					if hue > 70 && hue <= 175 {
						dominColor = "#00FF00"
					} else {
						// Желтый
						if hue < 70 {
							dominColor = "#FFFF00"
						}
					}
				}
			}
		}
	}
	return dominColor
}

func dominateColor2(img image.Image) (dominateColor string) {
	var (
		totalR, totalG, totalB, i, j int
		width                        int = 200
		height                       int = 200
	)
	var dominColor string = "undefined"

	// Подсчитать суммарные значения по RGB
	for i = 0; i < width; i++ {
		for j = 0; j < height; j++ {
			r, g, b, _ := img.At(int(i), int(j)).RGBA()
			//log.Print(r, g, b)
			totalR += int((r >> 16) & 0xFF)
			totalG += int((g >> 8) & 0xFF)
			totalB += int(b & 0xFF)
			//log.Print(totalR, totalG, totalB)

		}
	}
	// Определение значений RGB основного цвета
	avgR := math.Round(float64(totalR / width / height))
	avgG := math.Round(float64(totalG / width / height))
	avgB := math.Round(float64(totalB / width / height))

	log.Print(avgR, avgG, avgB)
	fmt.Printf("#%x%x%x", avgR, avgG, avgB)

	if avgR >= 0 && avgR <= 50 && avgG >= 0 && avgG <= 50 && avgB >= 0 && avgB <= 50 {
		// Черный
		log.Print("черный")
		dominColor = "#000000"
	}
	if avgR >= 105 && avgR <= 220 && avgG >= 105 && avgG <= 220 && avgB >= 105 && avgB <= 220 {
		// серый
		log.Print("Серый")
		dominColor = "#808080"
	}
	if avgR >= 205 && avgR <= 255 && avgG >= 200 && avgG <= 255 && avgB >= 200 && avgB <= 255 {
		// белый
		log.Print("Белый")
		dominColor = "#FFFFFF"
	}
	if avgR >= 238 && avgR <= 255 && avgG >= 218 && avgG <= 255 && avgB >= 0 && avgB <= 224 {
		// желтый
		log.Print("Желтый")
		dominColor = "#FFFF00"
	}
	if avgR >= 139 && avgR <= 255 && avgG >= 0 && avgG <= 160 && avgB >= 0 && avgB <= 128 {
		// red
		log.Print("Красный")
		dominColor = "#FF0000"
	}
	if avgR >= 199 && avgR <= 255 && avgG >= 20 && avgG <= 192 && avgB >= 133 && avgB <= 203 {
		// pink
		log.Print("Розовый")
		dominColor = "#FF1493"
	}
	if avgR == 255 && avgG >= 69 && avgG <= 165 && avgB >= 0 && avgB <= 80 {
		// orange
		log.Print("Оранжевый")
		dominColor = "#FF7F50"
	}
	if avgR >= 128 && avgR <= 255 && avgG >= 0 && avgG <= 222 && avgB >= 0 && avgB <= 205 {
		// коричневый
		log.Print("Коричневый")
		dominColor = "#8B4513"
	}
	if avgR >= 0 && avgR <= 173 && avgG >= 100 && avgG <= 255 && avgB >= 0 && avgB <= 170 {
		// Green
		log.Print("Зеленый")
		dominColor = "#32CD32"
	}
	if avgR >= 0 && avgR <= 224 && avgG >= 0 && avgG <= 255 && avgB >= 112 && avgB <= 155 {
		// Blue
		log.Print("Синий")
		dominColor = "#1E90FF"
	}
	if avgR >= 72 && avgR <= 255 && avgG >= 0 && avgG <= 191 && avgB >= 128 && avgB <= 255 {
		// фиолетовые
		log.Print("Фиолетовый")
		dominColor = "#BA55D3"
	}
	return dominColor
}
